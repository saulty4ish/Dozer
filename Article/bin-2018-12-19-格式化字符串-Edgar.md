# [Day0] #格式化字符的学习记录

***我们来看看格式化字符，听说也是一个特别好玩的一种漏洞！！***

我们先来看看基础知识，本漏洞主要是因为c语言那没事找事的转义符，
![printf]($res/printf.png)

### 格式化字符串函数 [¶](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro/#_3 "Permanent link")

常见的有格式化字符串函数有

*   输入
    *   scanf
*   输出

| 函数 | 基本介绍 |
| :-: | :-: |
| printf | 输出到 stdout |
| fprintf | 输出到指定 FILE 流 |
| vprintf | 根据参数列表格式化输出到 stdout |
| vfprintf | 根据参数列表格式化输出到指定 FILE 流 |
| sprintf | 输出到字符串 |
| snprintf | 输出指定字节数到字符串 |
| vsprintf | 根据参数列表格式化输出到字符串 |
| vsnprintf | 根据参数列表格式化输出指定字节到字符串 |
| setproctitle | 设置 argv |
| syslog | 输出日志 |
| err, verr, warn, vwarn 等 | 。。。 |
***没错就是这些函数可能会出问题***

然后再看看那个啥，格式化字符串是个什么样子：

```
 %[parameter][flags][field width][.precision][length]type
```
其实就是我们看到的c语言里面的%d，%s，%6.1lf这些鬼东西。
然后该看什么呢
* * type

*   d/i，有符号整数
*   u，无符号整数
*   x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。
*   o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。
*   s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。
*   c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。
*   p， void * 型，输出对应变量的值。printf("%p",a) 用地址的格式打印变量 a 的值，printf("%p", &a) 打印变量 a 所在的地址。
*   n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。
*   %， '`%`'字面值，不接受任何 flags, width。
这个应该就是我们天天看到的c语言程序里面的东西，然后总结一条经验c语言基础也是***很重要的！！！***

### 之后我们就看看格式化字符串漏洞原理
在看完ctf wiki之后我的理解就是说，要是说%[...]要是在后面不对应着参数就会读取栈上面的东西我们也知道printf之中的参数是放在栈上面的，要是没有和%[...]相对应的东西，那么就会读取栈上面的东西，要是有个%s，传递的要是一个啥来着，要是一个不合法地址，这个程序就崩了，啊哈哈哈哈哈。

未完待续哈哈哈哈……

这个文章的的表和图引用了：[Ctf-wiki](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/fmtstr/fmtstr_intro/)

